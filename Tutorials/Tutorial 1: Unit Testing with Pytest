Hereâ€™s the text content extracted from **pa1417-tutorial1-unit_testing.pptx.pdf** for AI processing:

---

### **PA1417: Basic System Verification**  
**Tutorial 1: Unit Testing with Pytest**  
*Julian Frattini*  

---

#### **Tutorial Structure**  
- Hands-on examples using **pytest** (no need to code live; examples are pre-configured in the repository).  
- All code is located in `backend/test/demo/`.  
- Focus on principles of test implementation to ensure tests fail only due to system defects, not test code flaws.  

---

### **Tutorial Content Overview**  
1. **Test Design**  
   - Valid ground truth for test cases (specifications, experience, documentation).  
   - Test case design techniques (BVA, EP, boundary conditions).  

2. **Python Dependencies**  
   - Required libraries: `pytest`, `pytest-cov`.  

3. **Basic Pytest Setup**  
   - Directory structure:  
     - Create `conftest.py` at the root.  
     - Place test files in `test/unit/` (prefix: `test_`).  
   - Optional: Configure with `pytest.ini`.  

4. **Unit Test Implementation**  
   - AAA template: **Arrange**, **Act**, **Assert**.  
   - Avoid control structures (loops, conditions) in test code.  

5. **Mocking & Parametrization**  
   - Use mocks to isolate dependencies (e.g., `ValidationHelper`).  
   - Parametrize tests for multiple input scenarios.  

6. **Coverage & Fixtures**  
   - Measure statement coverage with `pytest --cov`.  
   - Use fixtures to encapsulate setup/teardown logic.  

---

### **Unit Test Design**  
#### **Valid Ground Truth**  
Valid sources for test cases:  
- Requirements/system specifications  
- Experience  
- Documentation (e.g., docstrings)  

**Invalid sources**:  
- Code itself (white-box testing)  
- Opinion of a superior  

#### **Example: Test Case Design**  
For a method validating user age:  
| Test Case | Age | Expected Output |  
|-----------|-----|-----------------|  
| 1         | -1  | "invalid"       |  
| 2         | 0   | "underage"      |  
| 3         | 17  | "underaged"     |  
| 4         | 18  | "valid"         |  
| 5         | 121 | "invalid"       |  

---

### **Pytest Execution**  
#### **Basic Commands**  
```bash  
pytest  # Run all tests  
pytest --cov=src/util --cov-report term-missing  # Coverage report  
```  

#### **Output Interpretation**  
- `.` = Passed test  
- `F` = Failed test  
- Summary includes failed test names and error messages.  

---

### **Best Practices**  
1. **Test Independence**  
   - Tests must run in isolation/random order.  
   - Use fixtures for setup/teardown (e.g., `fixture_createObject()`).  

2. **Avoid Flaky Tests**  
   - Eliminate dependencies on environment/system state.  
   - Use Dockerized environments for consistency.  

3. **Code Reduction**  
   - Compress redundant code with fixtures and parametrization.  
   - Example:  
     ```python  
     @pytest.mark.parametrize("age, expected", [(18, "valid"), (17, "underaged")])  
     def test_age_validation(age, expected):  
         assert validate_age(age) == expected  
     ```  

---

### **Advanced Pytest Setup**  
#### **Configuration File (`pytest.ini`)**  
```ini  
[pytest]  
addopts = --cov=src --cov-report term-missing  
testpaths = test/unit/  
```  

#### **Markers**  
Use markers to group tests:  
```python  
@pytest.mark.demo  
def test_example():  
    assert True  
```  
Run marked tests:  
```bash  
pytest -m demo  
```  

---

### **Mocking Dependencies**  
#### **Example: Isolating `UserController`**  
```python  
from unittest.mock import Mock  

def test_user_validation():  
    mock_controller = Mock()  
    mock_controller.get.return_value = {"age": 18}  
    helper = ValidationHelper(mock_controller)  
    assert helper.validate_user(1) == "valid"  
```  

---

### **Coverage**  
#### **Statement Coverage**  
- Identify uncovered lines of code.  
- Command:  
  ```bash  
  pytest --cov=src/util --cov-report term-missing  
  ```  

---

### **Key Takeaways**  
1. Tests should fail only due to system defects.  
2. Use fixtures and parametrization to reduce redundancy.  
3. Measure coverage to evaluate test quality.  
4. Mock dependencies to isolate units under test.  

---
